grammar
  <- __ initializer:initializer? rules:rule+
  %{
    Initializer = get_value('initializer', Node),
    Rules = get_value('rules', Node),
    #ast{data = [
      {type,        "grammar"},
      {initializer, Initializer},
      {rules,       Rules}
    ]}
  %};

initializer
  <- code:action semicolon?
  %{
    Code = get_value('code', Node),
    #ast{data = [
      {type, "initializer"},
      {code, Code}
    ]}
  %};

rule
  <- name:identifier displayName:string? equals expression:expression semicolon?
  %{
    Expression = get_value(expression, Node),
    Name       = get_value(name, Node),
    case get_value(displayName, Node) of
      [] ->
        Expression;
      DisplayName ->
        #ast{data = [
          {type,        "rule"},
          {name,        Name},
          {expression,  [
                          {type,       "named"},
                          {name,       DisplayName},
                          {expression, Expression}
                        ]
          }
        ]}
     end
  %};

expression
  <- choice;

choice
  <- head:sequence tail:(slash sequence)*
  %{
    Head = get_value(head, Node),
    Tail = get_value(tail, Node),
    case Tail of
      [] ->
        Head;
      _List ->
        Alternatives0 = lists:foldl(
                          fun(E, Acc) ->
                            [_, Sequence] = E,
                            [Sequence | Acc]
                          end,
                          [Head],
                          Tail
                        ),
        Alternatives = lists:reverse(Alternatives0),
        #ast{data = [
          {type, "choice"},
          {alternatives, Alternatives}
        ]}
    end
  %};

sequence
  <- elements:labeled* code:action
  / elements:labeled*
  %{
    Node0 = case Node of
              N when is_list(N) -> N;
              _ -> [Node]
            end,
    Elements = get_value('elements', Node0),
    Code     = get_value('code', Node0),
    Expression = case Elements of
                   [OneElement] -> OneElement;
                   _ -> #ast{data = [
                                      {type, "sequence"},
                                      {elements, Elements}
                                    ]}
                 end,
    case Code of
      [] ->
        Expression;
      _     ->
        #ast{data = [
          {type, "action"},
          {expression, Expression},
          {code, Code}
        ]}
    end
  %};

labeled
  <- label:identifier colon expression:prefixed
  / prefixed;

prefixed
  <- dollar:dollar expression:suffixed
  / and:and code:action
  / and:and expression:suffixed
  / not:not code:action
  / not:not expression:suffixed
  / suffixed
  %{
    And        = get_value('and', Node),
    Code       = get_value('code', Node),
    Dollar     = get_value('dollar', Node),
    Expression = get_value('expression', Node),
    Not        = get_value('not', Node),

    case Dollar of
      [] ->
        case And of
          [] ->
            case Not of
              [] -> Node; %% suffixed
              _  ->
                case Code of
                  [] -> % not:not expression:suffixed
                    #ast{data = [
                      {type, "simple_not"},
                      {expression, Expression}
                    ]};
                  _  -> % not:not code:action
                    #ast{data = [
                      {type, "semantic_not"},
                      {code, Code}
                    ]}
                end
            end;
          _  ->
            case Code of
              [] -> % and:and expression:suffixed
                #ast{data = [
                  {type, "simple_and"},
                  {expression, Expression}
                ]};
              _  -> % and:and code:action
                #ast{data = [
                  {type, "semantic_and"},
                  {code, Code}
                ]}
            end
        end;
      _ ->  % ollar:dollar expression:suffixed
        #ast{data = [
          {type, "text"},
          {expression, Expression}
        ]}
    end
  %};

suffixed
  <- expression:primary suffix:question
  / expression:primary suffix:star
  / expression:primary suffix:plus
  / primary
  %{
    Expression = get_value('expression', Node),
    Suffix     = get_value('suffix', Node),
    case Expression of
      [] -> Node;
      _  ->
        case Suffix of
          <<"?">> ->
            #ast{data = [
              {type, "optional"},
              {expression, Expression}
            ]};
          <<"*">> ->
            #ast{data = [
              {type, "zero_or_more"},
              {expression, Expression}
            ]};
          <<"+">> ->
            #ast{data = [
              {type, "one_or_more"},
              {expression, Expression}
            ]}
        end
    end
  %};

primary
  <- name:identifier !(string? equals)
  / literal
  / class
  / dot
  / lparen expression:expression rparen
  %{
    case Node of
      <<".">> -> [{type, "any"}];
      [_, _] ->
        #ast{data = [
          {type, "rule_ref"},
          {name, get_value('name', Node)}
        ]};
      [_, _, _] ->
        get_value('expression', Node);
      _ ->
        Node
    end
  %};

%/* "Lexical" elements */

action
  <- braced:braced __
  %{
    Braced = get_value(braced, Node),
    binary:part(Braced, 1, size(Braced) - 2)
  %};

braced
  <-
  ("{" (braced / nonBraceCharacters)* "}")
  %{
    stringify(Node)
  %};

nonBraceCharacters
  <- nonBraceCharacter+;

nonBraceCharacter
  <- [^{}];

equals    <- "=" __ %{ <<"=">> %};
colon     <- ":" __ %{ <<":">> %};
semicolon <- ";" __ %{ <<";">> %};
slash     <- "/" __ %{ <<"/">> %};
and       <- "&" __ %{ <<"&">> %};
not       <- "!" __ %{ <<"!">> %};
dollar    <- "$" __ %{ <<"$">> %};
question  <- "?" __ %{ <<"?">> %};
star      <- "*" __ %{ <<"*">> %};
plus      <- "+" __ %{ <<"+">> %};
lparen    <- "(" __ %{ <<"(">> %};
rparen    <- ")" __ %{ <<")">> %};
dot       <- "." __ %{ <<".">> %};

%/*
% * Modeled after ECMA-262, 5th ed., 7.6, but much simplified:
% *
% * * no Unicode escape sequences
% *
% * * "Unicode combining marks" and "Unicode connection punctuation" can't be
% *   part of the identifier
% *
% * * only [a-zA-Z] is considered a "Unicode letter"
% *
% * * only [0-9] is considered a "Unicode digit"
% *
% * The simplifications were made just to make the implementation little bit
% * easier, there is no "philosophical" reason behind them.
% *
% * Contrary to ECMA 262, the "$" character is not valid because it serves other
% * purpose in the grammar.
% */

identifier
  <- chars:((letter / "_") (letter / digit / "_")*) __
  %{
    stringify(get_value(chars, Node))
  %};

%/*
% * Modeled after ECMA-262, 5th ed., 7.8.4. (syntax & semantics, rules only
% * vaguely).
% */
literal
  <- value:(doubleQuotedString / singleQuotedString) flags:"i"? __
  %{
  #ast{data= [
    {type, "literal"},
    {value, get_value('value', Node)},
    {ignoreCase, get_value('flags', Node) == <<"i">>}
  ]}
  %};

string
  <- string:(doubleQuotedString / singleQuotedString) __
  %{
    get_value('string', Node)
  %};

doubleQuotedString
  <- '"' chars:doubleQuotedCharacter* '"'
  %{
    stringify(get_value(chars, Node))
  %};

doubleQuotedCharacter
  <- simpleDoubleQuotedCharacter
  / simpleEscapeSequence
  / zeroEscapeSequence
  / hexEscapeSequence
  / unicodeEscapeSequence
  / eolEscapeSequence;

simpleDoubleQuotedCharacter
  <- !('"' / "\\" / eolChar) char_:.
  %{
    get_value('char_', Node)
  %};

singleQuotedString
  <- "'" chars:singleQuotedCharacter* "'"
  %{
    stringify(get_value(chars, Node))
  %};

singleQuotedCharacter
  <- simpleSingleQuotedCharacter
  / simpleEscapeSequence
  / zeroEscapeSequence
  / hexEscapeSequence
  / unicodeEscapeSequence
  / eolEscapeSequence;

simpleSingleQuotedCharacter
  <- !("'" / "\\" / eolChar) char_:.
  %{
    get_value('char_', Node)
  %}; % { return char_; }

class
  <- "[" inverted:"^"? parts:(classCharacterRange / classCharacter)* "]" flags:"i"? __
  %{
    Inverted = case get_value(inverted, Node) of [] -> <<>>; I -> I end,
    Parts = get_value(parts, Node),
    Flags = case get_value(flags, Node) of [] -> <<>>; F -> F end,

    PartsConverted = lists:map(fun(Part) -> get_value(data, Part) end, Parts),
    PartsRawText = << <<(get_attr(raw_text, Part))/binary>> || Part <- Parts>>,
    RawText = << "["
               , Inverted/binary
               , PartsRawText/binary
               , "]"
               , Flags/binary
              >>,
    #ast{data = [
      {type, "class"},
      {parts, PartsConverted},
      {raw_text, RawText},
      {inverted, Inverted == <<"^">>},
      {ignore_case, Flags == <<"i">>}
    ]}
  %};

classCharacterRange
  <- begin:classCharacter "-" end:classCharacter
  %{
    Begin = get_value('begin', Node),
    End = get_value('end', Node),
    RawBegin = get_attr(raw_text, Begin),
    RawEnd = get_attr(raw_text, End),
    case Begin > End of
      true ->
        error({invalid_character_range, {RawBegin, RawEnd}});
      false ->
        #ast{data = [
          {data, [get_value(data, Begin), get_value(data, End)]},
          {raw_text, <<RawBegin/binary, "-", RawEnd/binary>>}
        ]}
    end
  %};

classCharacter
  <- bracketDelimitedCharacter
  %{
    #ast{data = [
                   {data, Node},
                   {raw_text, quote_for_regexp_class(Node)}
                 ]
         }
  %};

bracketDelimitedCharacter
  <- simpleBracketDelimitedCharacter
  / simpleEscapeSequence
  / zeroEscapeSequence
  / hexEscapeSequence
  / unicodeEscapeSequence
  / eolEscapeSequence;

simpleBracketDelimitedCharacter
  <- !("]" / "\\" / eolChar) char_:.
  %{
    {_, Char} = lists:keyfind('char_', 1, Node),
    Char
  %};

simpleEscapeSequence
  <- "\\" !(digit / "x" / "u" / eolChar) char_:.
  %{
    {_, Char} = lists:keyfind('char_', 1, Node),
    case Char of
      <<"b">> -> <<"\b">>;
      <<"f">> -> <<"\f">>;
      <<"n">> -> <<"\n">>;
      <<"r">> -> <<"\r">>;
      <<"t">> -> <<"\t">>;
      <<"v">> -> <<"\v">>; %% or "\x{0B}"
      _       -> Char
    end
  %};

zeroEscapeSequence
  <- "\\0" !digit
  %{
    "\x{00}"
  %};

hexEscapeSequence
  <- "\\x" digits:(hexDigit hexDigit)
  %{
    Digits0 = get_value(digits, Node),
    Digits1 = [binary_to_list(D) || D <- Digits0],
    Digits = list_to_integer(lists:flatten(Digits1), 16),
    unicode:characters_to_binary([Digits])
  %};

unicodeEscapeSequence
  <- "\\u" digits:(hexDigit hexDigit hexDigit hexDigit)
  %{
    Digits0 = get_value(digits, Node),
    Digits1 = [binary_to_list(D) || D <- Digits0],
    Digits = list_to_integer(lists:flatten(Digits1), 16),
    unicode:characters_to_binary([Digits])
  %}
   ;

eolEscapeSequence
  <- "\\" eol:eol
  %{
    Eol = get_value(eol, Node),
    Eol
  %};

digit
  <- [0-9];

hexDigit
  <- [0-9a-fA-F];

letter
  <- lowerCaseLetter
  / upperCaseLetter;

lowerCaseLetter
  <- [a-z];

upperCaseLetter
  <- [A-Z];

__ <- (whitespace / eol / comment)*;

%/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
  <- singleLineComment
  / multiLineComment;

singleLineComment
  <- "//" (!eolChar .)*;

multiLineComment
  <- "/*" (!"*/" .)* "*/";

%/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
  <- "\n"
  / "\r\n"
  / "\r"
  / [\\x{2028}]
  / [\\x{2029}];

eolChar
  <- [\n\r\\x{2028}\\x{2029}];

%/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  <- [ \\t\\v\\f\\x{00A0}\\x{FEFF}\\x{1680}\\x{180E}\\x{2000}-\\x{200A}\\x{202F}\\x{205F}\\x{3000}];

`
-record(ast, {data = []}).

-type index() :: {Line::integer(), Column::integer()}.

-spec get_value(atom(), proplists:proplist()) -> term().
get_value(_, #ast{}) ->
  [];
get_value(K, L) ->
  case lists:keyfind(K, 1, L) of
    false  -> [];
    {_, V} -> V
  end.

-spec get_attr(atom(), #ast{}) -> term().
get_attr(K, #ast{data = L}) ->
  get_value(K, L).


-spec quote_for_regexp_class(string()) -> string().
%% Note: Unlike PEG.js, we don't need to escape Unicode symbols for regexps
quote_for_regexp_class(<<$\\>>) -> <<$\\, $\\>>; % backslash
quote_for_regexp_class(<<$/>>) -> <<$\\, $\\, $/>>; % closing slash
quote_for_regexp_class(<<$]>>) -> <<$\\, $\\, $]>>; % closing bracket
quote_for_regexp_class(<<$^>>) -> <<$\\, $\\, $^>>; % caret
quote_for_regexp_class(<<$->>) -> <<$\\, $\\, $->>; % dash
quote_for_regexp_class(<<$\0>>) -> <<$\\, $\\, $0>>; % null
quote_for_regexp_class(<<$\t>>) -> <<$\\, $\\, $t>>; % horizontal tab
quote_for_regexp_class(<<$\n>>) -> <<$\\, $\\, $n>>; % line feed
quote_for_regexp_class(<<$\v>>) -> <<$\\, $\\, $v>>; % vertical tab
quote_for_regexp_class(<<$\f>>) -> <<$\\, $\\, $f>>; % form feed
quote_for_regexp_class(<<$\r>>) -> <<$\\, $\\, $r>>; % carriage return
quote_for_regexp_class(C) -> C.


stringify(AST) ->
    << <<C>> || <<C>> <- lists:flatten(AST) >>.
`
