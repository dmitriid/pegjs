%% -type index() :: {{line, pos_integer()}, {column, pos_integer()}}.
-type input() :: binary().
-type index() :: {{line, integer()}, {column, integer()}}.
-type parse_failure() :: {error, term()}.
-type parse_success() :: {term(), input(), index()}.
-type parse_result() :: parse_failure() | parse_success().
-type parse_fun() :: fun((input(), index()) -> parse_result()).
-type xform_fun() :: fun((input(), index()) -> term()).

-spec pegjs(input(), index(), binary(), parse_fun(), xform_fun()) -> parse_result().
pegjs(Inp, StartIndex, Name, ParseFun, TransformFun) ->
  case get_memo(StartIndex, Name) of      % See if the current reduction is memoized
    {ok, Memo} -> %Memo;                     % If it is, return the stored result
      Memo;
    _ ->                                        % If not, attempt to parse
      Result = case ParseFun(Inp, StartIndex) of
        {error,_} = Failure ->                       % If it fails, memoize the failure
          Failure;
        {Match, InpRem, NewIndex} ->               % If it passes, transform and memoize the result.
          Transformed = TransformFun(Match, StartIndex),
          {Transformed, InpRem, NewIndex}
      end,
      memoize(StartIndex, Name, Result),
      Result
  end.

-spec setup_memo() -> ets:tid().
setup_memo() ->
  put({parse_memo_table, ?MODULE}, ets:new(?MODULE, [set])).

-spec release_memo() -> true.
release_memo() ->
  ets:delete(memo_table_name()).

-spec memoize(index(), atom(), term()) -> true.
memoize(Index, Name, Result) ->
  Memo = case ets:lookup(memo_table_name(), Index) of
              [] -> [];
              [{Index, Plist}] -> Plist
         end,
  ets:insert(memo_table_name(), {Index, [{Name, Result}|Memo]}).

-spec get_memo(index(), atom()) -> {ok, term()} | {error, not_found}.
get_memo(Index, Name) ->
  case ets:lookup(memo_table_name(), Index) of
    [] -> {error, not_found};
    [{Index, Plist}] ->
      case proplists:lookup(Name, Plist) of
        {Name, Result}  -> {ok, Result};
        _  -> {error, not_found}
      end
    end.

-spec memo_table_name() -> ets:tid().
memo_table_name() ->
    get({parse_memo_table, ?MODULE}).

pegjs_combinator('eof') ->
  fun(<<>>, Index) -> {eof, [], Index};
     (_, Index) -> {error, {expected, eof, Index}} end;

pegjs_combinator('anything') ->
  fun(<<>>, Index) -> {error, {expected, any_character, Index}};
     (Input, Index) when is_binary(Input) ->
          <<C/utf8, Rest/binary>> = Input,
          {<<C/utf8>>, Rest, p_advance_index(<<C/utf8>>, Index)}
  end.

%%_* Implemented combinators ===================================================

pegjs_combinator('choice', Parsers) ->
  fun(Input, Index) ->
      pegjs_combinator('attempt', {Parsers, Input, Index, none})
  end;

pegjs_combinator('attempt', {[], _Input, _Index, Failure}) -> Failure;
pegjs_combinator('attempt', {[P|Parsers], Input, Index, FirstFailure})->
  case P(Input, Index) of
    {error, _} = Failure ->
      case FirstFailure of
        none -> pegjs_combinator('attempt', {Parsers, Input, Index, Failure});
        _ -> pegjs_combinator('attempt', {Parsers, Input, Index, FirstFailure})
      end;
    Result -> Result
  end;

pegjs_combinator('sequence', P) ->
  fun(Input, Index) ->
      pegjs_combinator('all', {P, Input, Index, []})
  end;

pegjs_combinator('all', {[], Inp, Index, Accum}) -> {lists:reverse( Accum ), Inp, Index};
pegjs_combinator('all', {[P|Parsers], Inp, Index, Accum}) ->
  case P(Inp, Index) of
    {error, _} = Failure -> Failure;
    {Result, InpRem, NewIndex} -> pegjs_combinator('all', {Parsers, InpRem, NewIndex, [Result|Accum]})
  end;

pegjs_combinator('labeled', {Tag, [P]}) ->
  fun(Input, Index) ->
      case P(Input, Index) of
        {error,_} = Failure ->
           Failure;
        {Result, InpRem, NewIndex} ->
          case Tag of
            undefined -> {Result, InpRem, NewIndex};
            _         -> {{Tag, Result}, InpRem, NewIndex}
          end
      end
  end;

pegjs_combinator('prefixed', {simple_not, [P]}) ->
  fun(Input, Index)->
      case P(Input,Index) of
        {error,_} ->
          {[], Input, Index};
        {Result, _, _} -> {error, {expected, {no_match, Result},Index}}
      end
  end;
pegjs_combinator('prefixed', {simple_and, [P]}) ->
  fun(Input, Index) ->
    case P(Input, Index) of
      {error, _} = Failure -> Failure;
      _ -> {[], Input, Index}
    end
  end;

pegjs_combinator('suffixed', {zero_or_more, [P]}) ->
  fun(Input, Index) ->
      pegjs_combinator('scan', {P, Input, Index, []})
  end;
pegjs_combinator('suffixed', {one_or_more, [P]}) ->
  fun(Input, Index)->
      Result = pegjs_combinator('scan', {P, Input, Index, []}),
      case Result of
        {[_|_], _, _} ->
          Result;
        _ ->
          {error, {_, Failure, _}} = P(Input,Index),
          {error, {expected, {at_least_one, Failure}, Index}}
      end
  end;
pegjs_combinator('suffixed', {optional, [P]}) ->
  fun(Input, Index) ->
      case P(Input, Index) of
        {error,_} -> {[], Input, Index};
        {_, _, _} = Success -> Success
      end
  end;

pegjs_combinator('scan', { _, [], Index, Accum}) -> {lists:reverse( Accum ), [], Index};
pegjs_combinator('scan', {P, Inp, Index, Accum}) ->
  case P(Inp, Index) of
    {error,_N} -> {lists:reverse(Accum), Inp, Index};
    {Result, InpRem, NewIndex} -> pegjs_combinator('scan', {P, InpRem, NewIndex, [Result | Accum]})
  end;

pegjs_combinator('literal', {String, IsCaseInsensitive}) ->
    Length = erlang:byte_size(String),
    fun(Input, Index) ->
      case Input of
        <<String:Length/binary, Rest/binary>> ->
          {String, Rest, p_advance_index(String, Index)};
        _ ->
          Modifier = case IsCaseInsensitive of
                       true  -> case_insensitive;
                       false -> case_sensitive
                     end,
          case IsCaseInsensitive of
            false ->
              {error, { match_failed
                     , {expected_string, {String, Modifier}
                     , {actual_string, Input}
                     }, Index}};
            true ->
              case re:run( Input
                         , <<"^", String/binary, "(.*)">>
                         , [caseless]) of
                {match, [{_, Len}, _]} ->
                  <<Result:Len/binary, Rest/binary>> = Input,
                  { Result
                  , Rest
                  , p_advance_index(Result, Index)
                  };
                {match, _} ->
                  { Input
                  , <<>>
                  , p_advance_index(String, Index)
                  };
                nomatch    ->
                  {error, { match_failed
                         , {expected_string, {String, Modifier}
                         , {actual_string, Input}
                         }, Index}}
              end
          end
      end
    end;

pegjs_combinator('charclass', Class) ->
    {ok, RE} = re:compile(Class, [unicode, dotall]),
    fun(Inp, Index) ->
            case re:run(Inp, RE, [anchored]) of
                {match, [{0, Length}|_]} ->
                    {Head, Tail} = erlang:split_binary(Inp, Length),
                    {Head, Tail, p_advance_index(Head, Index)};
                _ -> {error, {expected, {character_class, binary_to_list(Class)}, Index}}
            end
    end;

pegjs_combinator('regexp', Regexp) ->
    {ok, RE} = re:compile(Regexp, [unicode, dotall, anchored]),
    fun(Inp, Index) ->
        case re:run(Inp, RE) of
            {match, [{0, Length}|_]} ->
                {Head, Tail} = erlang:split_binary(Inp, Length),
                {Head, Tail, p_advance_index(Head, Index)};
            _ -> {error, {expected, {regexp, binary_to_list(Regexp)}, Index}}
        end
    end;

pegjs_combinator('rule_ref', Rule) ->
    fun(Input, Index) ->
        pegjs_rule(Rule, Input, Index)
    end;

pegjs_combinator(Name, _) ->
  {error, {invalid_combinator, Name}}.

-spec line(index() | term()) -> pos_integer() | undefined.
line({{line,L},_}) -> L;
line(_) -> undefined.

-spec column(index() | term()) -> pos_integer() | undefined.
column({_,{column,C}}) -> C;
column(_) -> undefined.

p_advance_index(MatchedInput, Index) when is_list(MatchedInput) orelse is_binary(MatchedInput)-> % strings
  lists:foldl(fun p_advance_index/2, Index, unicode:characters_to_list(MatchedInput));
p_advance_index(MatchedInput, Index) when is_integer(MatchedInput) -> % single characters
  {{line, Line}, {column, Col}} = Index,
  case MatchedInput of
    $\n -> {{line, Line+1}, {column, 1}};
    _ -> {{line, Line}, {column, Col+1}}
  end.
