-type index() :: {{line, integer()}, {column, integer()}}.
-type input() :: binary().
-type parse_failure() :: {error, term()}.
-type parse_success() :: {term(), input(), index()}.
-type parse_result() :: parse_failure() | parse_success().
-type parse_fun() :: fun((input(), index()) -> parse_result()).
%-type xform_fun() :: fun((input(), index()) -> term()).

-record(pegjs_node, { input = <<>>
                    , index = {{line, 1}, {column, 1}}
                    , options = []
                    , match = []
                    }).

-define(DEBUG(W, Z), io:format("\n-------------\n" ++ W, Z)).

%-spec pegjs(input(), index(), binary(), parse_fun()
%, xform_fun()
%) -> parse_result().
-spec pegjs(#pegjs_node{}, binary(), parse_fun()) -> parse_result().
pegjs(#pegjs_node{index = StartIndex} = Node, Name, ParseFun) ->
  case get_memo(StartIndex, Name) of                 % See if the current reduction is memoized
    {ok, Memo} ->                                    % If it is, return the stored result
      Memo;
    _ ->                                             % If not, attempt to parse
      Result = case ParseFun(Node) of
        {error,_} = Failure ->                       % If it fails, memoize the failure
          Failure;
        #pegjs_node{} = Match ->                     % If it passes, transform and memoize the result.
          % Transformed = TransformFun(Match, StartIndex),
          %{Transformed, InpRem, NewIndex}
          Match;
        Other -> match(Other, Node)                  % for convenience, just return a match, no the full node
      end,
      memoize(StartIndex, Name, Result),
      Result
  end.

-spec setup_memo() -> ets:tid().
setup_memo() ->
  put({parse_memo_table, ?MODULE}, ets:new(?MODULE, [set])).

-spec release_memo() -> true.
release_memo() ->
  ets:delete(memo_table_name()).

-spec memoize(index(), atom(), term()) -> true.
memoize(Index, Name, Result) ->
  Memo = case ets:lookup(memo_table_name(), Index) of
              [] -> [];
              [{Index, Plist}] -> Plist
         end,
  ets:insert(memo_table_name(), {Index, [{Name, Result}|Memo]}).

-spec get_memo(index(), atom()) -> {ok, term()} | {error, not_found}.
get_memo(Index, Name) ->
  case ets:lookup(memo_table_name(), Index) of
    [] -> {error, not_found};
    [{Index, Plist}] ->
      case proplists:lookup(Name, Plist) of
        {Name, Result}  -> {ok, Result};
        _  -> {error, not_found}
      end
    end.

-spec memo_table_name() -> ets:tid().
memo_table_name() ->
    get({parse_memo_table, ?MODULE}).

%%_* Implemented combinators ===================================================

p_advance_index(MatchedInput, Index) when is_list(MatchedInput) orelse is_binary(MatchedInput)-> % strings
  lists:foldl(fun p_advance_index/2, Index, unicode:characters_to_list(MatchedInput));
p_advance_index(MatchedInput, Index) when is_integer(MatchedInput) -> % single characters
  {{line, Line}, {column, Col}} = Index,
  case MatchedInput of
    $\n -> {{line, Line+1}, {column, 1}};
    _ -> {{line, Line}, {column, Col+1}}
  end.

match(#pegjs_node{match = Match}) -> Match;
match(Other)                      -> Other.

match(New, Node)                  -> Node#pegjs_node{match = New}.

index(#pegjs_node{index = Index}) -> Index;
index(Other)                      -> Other.

input(#pegjs_node{input = Input}) -> Input;
input(Other)                      -> Other.

value(Label, #pegjs_node{match = Match}) ->
  value(Label, Match);
value(Label, {Label, Value}) -> Value;
value(Label, List) when is_list(List) ->
  case lists:keyfind(Label, 1, List) of
    {_, Value} -> Value;
    false      -> undefined
  end.

text(#pegjs_node{} = Node) ->
  iolist_to_binary(text(match(Node)));
text(B) when is_binary(B) ->
  B;
text({_, Value}) ->  %% labels
  text(Value);
text(List) when is_list(List) ->
  [text(E) || E <- List].
