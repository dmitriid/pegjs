%%%-----------------------------------------------------------------------------
%%% @doc Generate QuickCheck models for a PEG.js grammar
%%% @author Dmitrii Dimandt <dmitrii@dmitriid.com>
%%%
%%%-----------------------------------------------------------------------------
-module(pegjs2_generate_eqc_model).

%%_* Exports ===================================================================
-export([ generate/1
        ]).

%%_* Includes ==================================================================
-include("pegjs2.hrl").

%%_* Types =====================================================================

%%_* API =======================================================================

%%
%% @doc fn-genrator ignores any generated bytecode and uses only the grammar
%%
-spec generate(#analysis{}) -> any().
generate(#analysis{ grammar = Grammar
                  %, combinators = Combinators
                  , options = Options
                  , combinators = Combinators
                  }) ->
  FileName0 = proplists:get_value(output, Options),
  FileName = filename:rootname(FileName0)
              ++ "_eqc_model"
              ++ filename:extension(FileName0),
  io:format("~s~n", [FileName]),
  file:delete(FileName),
  {ok, F} = file:open(FileName, [append]),
  write( F
       , [ {fun generate_prelude/1, [Options]}
         , {fun generate_exports/1, [Options]}
         , {fun generate_initial_call/2, [Grammar, Options]}
         , {fun generate_rules/1, [Grammar]}
         , {fun generate_combinators/1, [Combinators]}
         ]),
  file:close(F), ok.

%%_* Internal ==================================================================

generate_rules(#entry{type = <<"grammar">>
                     , rules = Rules
                     }) ->
  {ok, generate_rules(Rules)};
generate_rules([H|[]]) ->
  <<(generate_rule(H))/binary, ".\n\n">>;
generate_rules([H|T]) ->
  <<(generate_rule(H))/binary, ".\n\n", (generate_rules(T))/binary>>;
generate_rules([]) ->
  <<>>.

generate_rule(#entry{ name = Name
                    , expression = Expression}) ->
  <<"'", Name/binary, "'() -> \n"
  , "  ", (generate_combinator_call(Expression))/binary, "\n"
  >>.

generate_combinator_call(#entry{type = <<"any">>}) ->
  <<"pegjs_combinator_any()">>;
generate_combinator_call(#entry{ type = <<"choice">>
                               , alternatives = Elements}) ->
  <<"pegjs_combinator_choice(["
  , (generate_combinator_list(Elements))/binary
  , "])">>;
generate_combinator_call(#entry{ type = <<"sequence">>
                               , elements = Elements}) ->
  <<"pegjs_combinator_sequence(["
  , (generate_combinator_list(Elements))/binary
  , "])">>;
generate_combinator_call(#entry{ type = <<"literal">>
                               , value = Text
                               , ignore_case = IgnoreCase}) ->
  Chars0 = iolist_to_binary(Text),
  Chars = list_of_ints_to_binary(Chars0),
  <<"pegjs_combinator_literal("
  , "", Chars/binary, ", "
  , (atom_to_binary(IgnoreCase, latin1))/binary
  , ")">>;
generate_combinator_call(#entry{ type = <<"class">>
                               , parts = Parts
                               , ignore_case = IgnoreCase
                               , inverted = Inverted}) ->
  Ps0 = lists:map(fun(B) when is_binary(B) ->
                      pegjs_util:escape_for_regex(B);
                    ([B1, B2]) ->
                      [ pegjs_util:escape_for_regex(B1)
                      , pegjs_util:escape_for_regex(B2)
                      ]
                  end, Parts),
  Ps = io_lib:format("~p", [Ps0]),
  <<"pegjs_combinator_regexp("
  , "", (iolist_to_binary(Ps))/binary, ", "
  , (atom_to_binary(Inverted, latin1))/binary, ", "
  , (atom_to_binary(IgnoreCase, latin1))/binary
  , ")">>;
generate_combinator_call(#entry{ type = <<"rule_ref">>
                               , name = Name}) ->
  <<"'", Name/binary, "'()">>;
generate_combinator_call(#entry{ type = Type
                               , expression = Expression})
  when Type =:= <<"zero_or_more">>
     ; Type =:= <<"one_or_more">>
     ; Type =:= <<"optional">>   ->
  <<"pegjs_combinator_suffixed('", Type/binary, "', "
  , (generate_combinator_call(Expression))/binary
  ,")">>;
generate_combinator_call(#entry{ type = Type
                               , expression = Expression})
  when Type =:= <<"simple_and">>
     ; Type =:= <<"simple_not">> ->
  <<"pegjs_combinator_prefixed('", Type/binary, "', "
  , (generate_combinator_call(Expression))/binary
  ,")">>;
generate_combinator_call(#entry{ type = <<"text">>
                               , expression = Expression}) ->
  <<"pegjs_combinator_text("
  , (generate_combinator_call(Expression))/binary
  ,")">>;
generate_combinator_call(#entry{ type = <<"labeled">>
                               , label = _Label
                               , expression = Expression}) ->
  <<"pegjs_combinator_labeled(["
  , (generate_combinator_call(Expression))/binary
  ,"])">>;
generate_combinator_call(#entry{ type = <<"action">>
                               , expression = Expression
                               , index = _Index}) ->
  <<"pegjs_combinator_action("
  , (generate_combinator_call(Expression))/binary
  ,")">>;
generate_combinator_call(#entry{ type = Type })
  when Type =:= <<"semantic_and">>
     ; Type =:= <<"semantic_not">> ->
  <<"pegjs_combinator_prefixed('", Type/binary, "', dummy)">>;
generate_combinator_call(#entry{ type = <<"named">>
                               , expression = Expression}) ->
  <<"pegjs_combinator_named(["
  , (generate_combinator_call(Expression))/binary
  ,"])">>;
generate_combinator_call([Entry|[]]) ->
  generate_combinator_call(Entry).


generate_combinator_list([]) ->
  <<>>;
generate_combinator_list([H|[]]) ->
  <<(generate_combinator_call(H))/binary>>;
generate_combinator_list([H | T]) ->
  <<(generate_combinator_call(H))/binary
  , ", "
  , (generate_combinator_list(T))/binary>>.

%%_* Helpers ===================================================================
write(File, FunList) ->
  lists:foldl(fun({F, A}, _) ->
                case apply(F, A) of
                  {error, _} = E -> error(E);
                  {ok, V}        -> file:write(File, V)
                end
              end, ok, FunList).

generate_prelude(Options) ->
  ModuleName = proplists:get_value(module, Options),
  Module = <<(atom_to_binary(ModuleName, latin1))/binary, "_eqc_model">>,
  {ok, <<"-module('", Module/binary, "').\n\n"
       , "-include_lib(\"eqc/include/eqc.hrl\").\n\n">>}.

generate_exports(_Options) ->
  {ok,
  <<"%%_* API "
  , "===================================================================\n"
  , "-export([ model/0\n"
  , "        ]).\n\n"
  >>}.

generate_initial_call(#entry{rules = [H|_]}, Options) ->
  Root = case proplists:get_value(starte_rule, Options) of
           undefined -> H#entry.name;
           Name      -> Name
         end,
  Out =
    <<"-spec model() -> binary().\n"
    , "model() -> '", Root/binary, "'().\n\n"
    >>,
  {ok, Out}.

generate_combinators(Combinators) ->
  File = filename:join([code:priv_dir(pegjs), "pegjs_eqc_model.eterm"]),
  {ok, Existing} = file:consult(File),
  Required = [C || {C, _} <- dict:to_list(Combinators)],
  generate_combinators(Required, Existing).

generate_combinators(Required, Existing) ->
  Cs = lists:foldl(fun(C, Acc) ->
                     {_, Reqs, Code} = lists:keyfind(C, 1, Existing),
                     {ok, MoreCode} = generate_combinators(Reqs, Existing),
                     [Code, MoreCode | Acc]
                   end, [], Required),
  {ok, lists:usort(Cs)}.


list_of_ints_to_binary(Ints) ->
  <<"<<", (to_list_of_ints(Ints))/binary, ">>">>.

to_list_of_ints(<<>>) ->
  <<>>;
to_list_of_ints(<<I/integer, R/binary>>) when R =:= <<>> ->
  <<(int_to_binary(I))/binary>>;
to_list_of_ints(<<I/integer, H/binary>>) ->
  <<(int_to_binary(I))/binary
  , ","
  , (to_list_of_ints(H))/binary>>.

%% Accomodates earlier versions of Erlang which don't have
%% integer_to_binary/1
int_to_binary(I) ->
  list_to_binary(integer_to_list(I)).